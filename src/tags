!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	0.0.0	/3fdf28bc/
AE	./multi_ae.py	/^class AE(nn.Module):$/;"	c
AETrainer	./multi_ae.py	/^class AETrainer():$/;"	c
AEs	./multi_ae.py	/^    AEs = []$/;"	v
ARGS	./ae_experiments.py	/^    ARGS = parser.parse_args()$/;"	v
ARGS	./min_ex.py	/^    ARGS = parser.parse_args()$/;"	v
ARGS	./multi_ae.py	/^    ARGS = parser.parse_args()$/;"	v
ARGSl	./multi_ae.py	/^    ARGSl = [ARGS,ARGS]$/;"	v
ConceptLearner	./ae_experiments.py	/^class ConceptLearner():$/;"	c
ConceptLearner	./min_ex.py	/^class ConceptLearner():$/;"	c
DATASET	./multi_ae.py	/^    DATASET = utils.get_mnist_dset()$/;"	v
Dataholder	./utils.py	/^class Dataholder():$/;"	c
EncoderStacked	./utils.py	/^class EncoderStacked(nn.Module):$/;"	c
F	./ae_experiments.py	/^import torch.nn.functional as F$/;"	I
F	./min_ex.py	/^import torch.nn.functional as F$/;"	I
F	./multi_ae.py	/^import torch.nn.functional as F$/;"	I
F	./train_stacked.py	/^import torch.nn.functional as F$/;"	I
Generator	./utils.py	/^class Generator(nn.Module):$/;"	c
GeneratorStacked	./utils.py	/^class GeneratorStacked(nn.Module):$/;"	c
KwargTransformDataset	./utils.py	/^class KwargTransformDataset(data.Dataset):$/;"	c
LOAD_START_TIME	./ae_experiments.py	/^    global LOAD_START_TIME; LOAD_START_TIME = time()$/;"	v
LOAD_START_TIME	./min_ex.py	/^    global LOAD_START_TIME; LOAD_START_TIME = time()$/;"	v
LOAD_START_TIME	./multi_ae.py	/^    global LOAD_START_TIME; LOAD_START_TIME = time()$/;"	v
NZ	./train_stacked.py	/^NZ=50$/;"	v
NonsenseDiscriminator	./utils.py	/^class NonsenseDiscriminator(nn.Module):$/;"	c
SuperAE	./utils.py	/^class SuperAE(nn.Module):$/;"	c
TransformDataset	./utils.py	/^class TransformDataset(data.Dataset):$/;"	c
__getitem__	./utils.py	/^    def __getitem__(self,idx): $/;"	m	class:KwargTransformDataset
__getitem__	./utils.py	/^    def __getitem__(self,idx): $/;"	m	class:TransformDataset
__init__	./ae_experiments.py	/^    def __init__(self,enc,dec,lin,dataset,opt,loss_func,discrim=None): $/;"	m	class:ConceptLearner
__init__	./min_ex.py	/^    def __init__(self,enc,dec,dataset,opt,loss_func,discrim=None): $/;"	m	class:ConceptLearner
__init__	./multi_ae.py	/^    def __init__(self,args): $/;"	m	class:AETrainer
__init__	./multi_ae.py	/^    def __init__(self,enc,dec,identifier): $/;"	m	class:AE
__init__	./utils.py	/^    def __init__(self):$/;"	m	class:NonsenseDiscriminator
__init__	./utils.py	/^    def __init__(self, nz,ngf,nc,dropout_p=0.):$/;"	m	class:Generator
__init__	./utils.py	/^    def __init__(self, nz,ngf,nc,dropout_p=0.):$/;"	m	class:GeneratorStacked
__init__	./utils.py	/^    def __init__(self,block1,block2): $/;"	m	class:EncoderStacked
__init__	./utils.py	/^    def __init__(self,data,transforms,x_only,device): $/;"	m	class:TransformDataset
__init__	./utils.py	/^    def __init__(self,num_aes,latent_size,device):$/;"	m	class:SuperAE
__init__	./utils.py	/^    def __init__(self,train_data,train_labels): self.train_data,self.train_labels=train_data,tra/;"	m	class:Dataholder
__init__	./utils.py	/^    def __init__(self,transforms,device,**kwdata): $/;"	m	class:KwargTransformDataset
__len__	./utils.py	/^    def __len__(self): return len(getattr(self,self.data_names[0]))$/;"	m	class:KwargTransformDataset
__len__	./utils.py	/^    def __len__(self): return len(self.data) if self.x_only else len(self.x)$/;"	m	class:TransformDataset
_comp	./utils.py	/^    def _comp(x):$/;"	f	function:compose	file:
add_colour_dimension	./utils.py	/^def add_colour_dimension(item): return item.unsqueeze(0) if item.dim() == 2 else item.unsqueeze(/;"	f
aetrainer	./multi_ae.py	/^    aetrainer = AETrainer(ARGS)$/;"	v
all_agree	./multi_ae.py	/^                mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrai/;"	v
all_agree	./multi_ae.py	/^            mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrainer./;"	v
asMinutes	./utils.py	/^def asMinutes(s):$/;"	f
ask_ensemble	./utils.py	/^def ask_ensemble(l): return (np.expand_dims(np.arange(l.max()+1),0)==np.expand_dims(l,2)).sum(ax/;"	f
build_ensemble_gt	./multi_ae.py	/^    def build_ensemble_gt(self,ensemble_results):$/;"	m	class:AETrainer
check_ae_images	./ae_experiments.py	/^    def check_ae_images(self,num_rows=5):$/;"	m	class:ConceptLearner
check_ae_images	./utils.py	/^def check_ae_images(enc,dec,dataset):$/;"	f
check_ae_images	./utils.py	/^def check_ae_images(enc,dec,dataset,num_rows=5,stacked=False):$/;"	f
check_latents	./ae_experiments.py	/^    def check_latents(self,latents,show=False):$/;"	m	class:ConceptLearner
check_latents	./min_ex.py	/^    def check_latents(self,latents,show,stacked):$/;"	m	class:ConceptLearner
check_latents	./multi_ae.py	/^    def check_latents(self,latents,show,stacked):$/;"	m	class:AETrainer
check_ohe_latents	./utils.py	/^def check_ohe_latents(dec,t):$/;"	f
clearner	./min_ex.py	/^        clearner = ConceptLearner(enc,dec,mnist,opt=torch.optim.Adam,loss_func=nn.L1Loss(reducti/;"	v
clearners	./min_ex.py	/^    clearners = []$/;"	v
cluster	./umap_reproduce.py	/^import sklearn.cluster as cluster$/;"	I
clusterable_embedding	./umap_reproduce.py	/^clusterable_embedding = umap.UMAP(n_neighbors=30, min_dist=0.0, n_components=2, random_state=42)/;"	v
cm	./utils.py	/^import matplotlib.cm as cm$/;"	I
compose	./utils.py	/^def compose(funcs):$/;"	f
ctx	./multi_ae.py	/^        ctx = mp.get_context("spawn")$/;"	v
d	./test_super.py	/^d = utils.get_mnist_dset()$/;"	v
d	./test_super_fwd.py	/^d = utils.get_mnist_dset()$/;"	v
debable	./utils.py	/^def debable(labellings_list):$/;"	f
dec	./ae_experiments.py	/^    enc,dec,lin = utils.get_enc_dec('cuda',latent_size=ARGS.NZ)$/;"	v
dec	./min_ex.py	/^        dec = utils.GeneratorStacked(nz=ARGS.NZ,ngf=32,nc=1,dropout_p=0.)$/;"	v
dec	./multi_ae.py	/^        dec = utils.GeneratorStacked(nz=ARGS.NZ,ngf=32,nc=1,dropout_p=0.)$/;"	v
dec	./train_stacked.py	/^dec = utils.GeneratorStacked(nz=NZ,ngf=32,nc=1,dropout_p=0.)$/;"	v
dec_mid	./train_stacked.py	/^        dec_mid, pred = dec(latent)$/;"	v
decode_all	./utils.py	/^    def decode_all(self,x):$/;"	m	class:SuperAE
decode_list	./utils.py	/^    def decode_list(self,latent_list):$/;"	m	class:SuperAE
dl	./test_super.py	/^dl = utils.get_mnist_dloader()$/;"	v
dl	./test_super_fwd.py	/^dl = utils.get_mnist_dloader()$/;"	v
dl	./train_stacked.py	/^dl = utils.get_mnist_dloader(x_only=True)$/;"	v
duplicate_dim	./utils.py	/^def duplicate_dim(enc,dec,lin,idx):$/;"	f
eights	./ae_experiments.py	/^    eights = mnist_train.x[(mnist_train.y == 8)].to('cuda')$/;"	v
enc	./ae_experiments.py	/^    enc,dec,lin = utils.get_enc_dec('cuda',latent_size=ARGS.NZ)$/;"	v
enc	./min_ex.py	/^        enc = utils.EncoderStacked(enc_b1,enc_b2)$/;"	v
enc	./multi_ae.py	/^        enc = utils.EncoderStacked(enc_b1,enc_b2)$/;"	v
enc	./train_stacked.py	/^enc = utils.EncoderStacked(enc_b1,enc_b2)$/;"	v
enc_b1	./min_ex.py	/^        enc_b1, enc_b2 = utils.get_enc_blocks('cuda',ARGS.NZ)$/;"	v
enc_b1	./multi_ae.py	/^        enc_b1, enc_b2 = utils.get_enc_blocks('cuda',ARGS.NZ)$/;"	v
enc_b1	./train_stacked.py	/^enc_b1, enc_b2 = utils.get_enc_blocks('cuda',NZ)$/;"	v
enc_b2	./min_ex.py	/^        enc_b1, enc_b2 = utils.get_enc_blocks('cuda',ARGS.NZ)$/;"	v
enc_b2	./multi_ae.py	/^        enc_b1, enc_b2 = utils.get_enc_blocks('cuda',ARGS.NZ)$/;"	v
enc_b2	./train_stacked.py	/^enc_b1, enc_b2 = utils.get_enc_blocks('cuda',NZ)$/;"	v
enc_mid	./train_stacked.py	/^        enc_mid, latent = enc(xb)$/;"	v
encode	./utils.py	/^    def encode(self,x):$/;"	m	class:SuperAE
ensemble_labels	./multi_ae.py	/^                mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrai/;"	v
ensemble_labels	./multi_ae.py	/^            mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrainer./;"	v
filled_train	./multi_ae.py	/^            filled_train = partial(aetrainer.train_ae,mid_centroids_by_id=mid_centroids_by_id,la/;"	v
fives	./ae_experiments.py	/^    fives = mnist_train.x[(mnist_train.y == 5)].to('cuda')$/;"	v
forward	./utils.py	/^    def forward(self, inp):$/;"	m	class:Generator
forward	./utils.py	/^    def forward(self,inp):$/;"	m	class:EncoderStacked
forward	./utils.py	/^    def forward(self,inp):$/;"	m	class:GeneratorStacked
forward	./utils.py	/^    def forward(self,inp_):$/;"	m	class:NonsenseDiscriminator
forward	./utils.py	/^    def forward(self,x):$/;"	m	class:SuperAE
fours	./ae_experiments.py	/^    fours = mnist_train.x[(mnist_train.y == 4)].to('cuda')$/;"	v
generate_mids_and_latents	./multi_ae.py	/^def generate_mids_and_latents(dset,enc):$/;"	f
get_confusion_mat	./utils.py	/^def get_confusion_mat(labels1,labels2):$/;"	f
get_datetime_stamp	./utils.py	/^def get_datetime_stamp(): return str(datetime.now()).split()[0][5:] + '_'+str(datetime.now().tim/;"	f
get_dloader	./utils.py	/^def get_dloader(raw_data,x_only,batch_size,device,random=True):$/;"	f
get_dset	./utils.py	/^def get_dset(raw_data,x_only,device,tfms=None):$/;"	f
get_enc_blocks	./utils.py	/^def get_enc_blocks(device, latent_size):$/;"	f
get_enc_dec	./utils.py	/^def get_enc_dec(device, latent_size):$/;"	f
get_far_tensor	./utils.py	/^def get_far_tensor(exemplars_tensor):$/;"	f
get_gauss_loss	./min_ex.py	/^                def get_gauss_loss(preds,centroids,targets):$/;"	f	member:ConceptLearner.train_labels	file:
get_gauss_loss	./multi_ae.py	/^                def get_gauss_loss(preds,centroids,targets):$/;"	f	member:AETrainer.train_ae	file:
get_mnist_dloader	./utils.py	/^def get_mnist_dloader(x_only=False,device='cuda',bs=64):$/;"	f
get_mnist_dset	./utils.py	/^def get_mnist_dset(device='cuda',x_only=False):$/;"	f
get_num_labels	./multi_ae.py	/^def get_num_labels(labels): $/;"	f
get_reslike_block	./utils.py	/^def get_reslike_block(nfs,sz):$/;"	f
get_user_yesno_answer	./utils.py	/^def get_user_yesno_answer(question):$/;"	f
hdbscan_labels	./umap_reproduce.py	/^hdbscan_labels = hdbscan.HDBSCAN(min_samples=10, min_cluster_size=500).fit_predict(lowd_mnist)$/;"	v
hdbscan_labels	./umap_reproduce.py	/^hdbscan_labels = hdbscan.HDBSCAN(min_samples=10,min_cluster_size=500,).fit_predict(clusterable_e/;"	v
kmeans_labels	./umap_reproduce.py	/^kmeans_labels = cluster.KMeans(n_clusters=10).fit_predict(mnist_data)$/;"	v
label_assignment_cost	./utils.py	/^def label_assignment_cost(labels1,labels2,label1,label2):$/;"	f
latent	./train_stacked.py	/^        enc_mid, latent = enc(xb)$/;"	v
latent_centroids_by_id	./multi_ae.py	/^                mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrai/;"	v
latent_centroids_by_id	./multi_ae.py	/^            mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrainer./;"	v
latent_labels_by_id	./multi_ae.py	/^            mid_labels_by_id, latent_labels_by_id = aetrainer.load_saved_labels(range(ARGS.num_a/;"	v
latents	./multi_ae.py	/^                mids,latents = generate_mids_and_latents(DATASET,ae.enc)$/;"	v
latents	./test_super.py	/^        latents = s.encode(xb)$/;"	v
latents	./test_super.py	/^latents = s.encode(x)$/;"	v
latents	./test_super_fwd.py	/^latents = s.encode(x)$/;"	v
latents_by_id	./multi_ae.py	/^            mids_by_id,latents_by_id = {},{}$/;"	v
lf	./test_super.py	/^lf = nn.L1Loss()$/;"	v
lf	./test_super_fwd.py	/^lf = nn.L1Loss()$/;"	v
lf	./train_stacked.py	/^lf = nn.L1Loss()$/;"	v
lin	./ae_experiments.py	/^    enc,dec,lin = utils.get_enc_dec('cuda',latent_size=ARGS.NZ)$/;"	v
load_ensemble	./multi_ae.py	/^    def load_ensemble(self,aeids):$/;"	m	class:AETrainer
load_saved_labels	./multi_ae.py	/^    def load_saved_labels(self,aeids):$/;"	m	class:AETrainer
loaded_results	./multi_ae.py	/^            loaded_results = {aeid:{'mids':mids_by_id[aeid],'latent':latents_by_id[aeid],'mid_la/;"	v
loss	./test_super.py	/^        loss = sum([lf(pred,xb) for pred in preds])$/;"	v
loss	./test_super_fwd.py	/^        loss = sum([lf(pred,xb) for pred in preds])$/;"	v
loss	./train_stacked.py	/^        loss = mid_loss + pred_loss$/;"	v
lowd_mnist	./umap_reproduce.py	/^lowd_mnist = PCA(n_components=50).fit_transform(mnist_data)$/;"	v
mid_centroids_by_id	./multi_ae.py	/^                mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrai/;"	v
mid_centroids_by_id	./multi_ae.py	/^            mid_centroids_by_id, latent_centroids_by_id, ensemble_labels, all_agree = aetrainer./;"	v
mid_labels_by_id	./multi_ae.py	/^            mid_labels_by_id, latent_labels_by_id = aetrainer.load_saved_labels(range(ARGS.num_a/;"	v
mid_loss	./train_stacked.py	/^        mid_loss = lf(enc_mid,dec_mid)$/;"	v
mids	./multi_ae.py	/^                mids,latents = generate_mids_and_latents(DATASET,ae.enc)$/;"	v
mids_by_id	./multi_ae.py	/^            mids_by_id,latents_by_id = {},{}$/;"	v
mnist	./ae_experiments.py	/^    mnist = utils.get_mnist_dset()$/;"	v
mnist	./min_ex.py	/^    mnist = utils.get_mnist_dset()$/;"	v
mnist	./multi_ae.py	/^    mnist = utils.get_mnist_dset()$/;"	v
mnist_data	./umap_reproduce.py	/^mnist_data, mnist_labels = fetch_openml('mnist_784', version=1, return_X_y=True)$/;"	v
mnist_ds	./ae_experiments.py	/^    mnist_ds = utils.get_mnist_dset(x_only=True)$/;"	v
mnist_ds	./min_ex.py	/^    mnist_ds = utils.get_mnist_dset(x_only=True)$/;"	v
mnist_ds	./multi_ae.py	/^    mnist_ds = utils.get_mnist_dset(x_only=True)$/;"	v
mnist_labels	./umap_reproduce.py	/^mnist_data, mnist_labels = fetch_openml('mnist_784', version=1, return_X_y=True)$/;"	v
mnist_labels	./umap_reproduce.py	/^mnist_labels = mnist_labels.astype(np.float)$/;"	v
mnist_train	./ae_experiments.py	/^    mnist_train = utils.get_mnist_dset(x_only=False)$/;"	v
mnist_train	./min_ex.py	/^    mnist_train = utils.get_mnist_dset(x_only=False)$/;"	v
mnist_train	./multi_ae.py	/^    mnist_train = utils.get_mnist_dset(x_only=False)$/;"	v
mp	./multi_ae.py	/^        import multiprocessing as mp$/;"	I
nines	./ae_experiments.py	/^    nines = mnist_train.x[(mnist_train.y == 9)].to('cuda')$/;"	v
nn	./ae_experiments.py	/^import torch.nn as nn$/;"	I
nn	./min_ex.py	/^import torch.nn as nn$/;"	I
nn	./multi_ae.py	/^import torch.nn as nn$/;"	I
nn	./test_super.py	/^import torch.nn as nn$/;"	I
nn	./test_super_fwd.py	/^import torch.nn as nn$/;"	I
nn	./train_stacked.py	/^import torch.nn as nn$/;"	I
nn	./utils.py	/^import torch.nn as nn$/;"	I
noiseify	./utils.py	/^def noiseify(pytensor,constant):$/;"	f
normalize	./utils.py	/^def normalize(t): return t\/t.norm()$/;"	f
normalize_leaf	./utils.py	/^def normalize_leaf(t): return torch.tensor(t.data)\/t.data.norm()$/;"	f
np	./ae_experiments.py	/^import numpy as np$/;"	I
np	./min_ex.py	/^import numpy as np$/;"	I
np	./multi_ae.py	/^import numpy as np$/;"	I
np	./train_stacked.py	/^import numpy as np$/;"	I
np	./umap_reproduce.py	/^import numpy as np$/;"	I
np	./utils.py	/^import numpy as np$/;"	I
numpyify	./utils.py	/^def numpyify(x):$/;"	f
oheify	./utils.py	/^def oheify(x):$/;"	f
ones	./ae_experiments.py	/^    ones = mnist_train.x[(mnist_train.y == 1)].to('cuda')$/;"	v
opt	./test_super.py	/^opt = torch.optim.Adam(s.parameters())$/;"	v
opt	./test_super_fwd.py	/^opt = torch.optim.Adam(s.parameters())$/;"	v
opt	./train_stacked.py	/^opt = torch.optim.Adam([{'params': enc.parameters()},{'params':dec.parameters()}])$/;"	v
parser	./ae_experiments.py	/^    parser = argparse.ArgumentParser()$/;"	v
parser	./min_ex.py	/^    parser = argparse.ArgumentParser()$/;"	v
parser	./multi_ae.py	/^    parser = argparse.ArgumentParser()$/;"	v
plt	./ae_experiments.py	/^import matplotlib.pyplot as plt$/;"	I
plt	./min_ex.py	/^import matplotlib.pyplot as plt$/;"	I
plt	./multi_ae.py	/^import matplotlib.pyplot as plt$/;"	I
plt	./train_stacked.py	/^import matplotlib.pyplot as plt$/;"	I
plt	./umap_reproduce.py	/^import matplotlib.pyplot as plt$/;"	I
plt	./utils.py	/^import matplotlib.pyplot as plt$/;"	I
pred	./test_super.py	/^pred = s.decode_list(latents)$/;"	v
pred	./test_super_fwd.py	/^pred = s.decode_list(latents)$/;"	v
pred	./train_stacked.py	/^        dec_mid, pred = dec(latent)$/;"	v
pred_loss	./train_stacked.py	/^        pred_loss = lf(pred,xb)$/;"	v
predict	./utils.py	/^    def predict(self,inp_):$/;"	m	class:NonsenseDiscriminator
preds	./test_super.py	/^        preds = s.decode_list(latents)$/;"	v
preds	./test_super_fwd.py	/^        preds = s(xb)$/;"	v
pretrain_ae	./multi_ae.py	/^    def pretrain_ae(self,AE):$/;"	m	class:AETrainer
pretrain_results	./multi_ae.py	/^                pretrain_results = pool.map(aetrainer.pretrain_ae, AEs)$/;"	v
pretrain_results	./multi_ae.py	/^                pretrain_results = {r['aeid']: r for r in pretrain_results}$/;"	v
print_tensors	./utils.py	/^def print_tensors(*tensors):$/;"	f
prune	./utils.py	/^def prune(enc,dec,lin,idx):$/;"	f
reload	./utils.py	/^def reload():$/;"	f
s	./test_super.py	/^s = utils.SuperAE(5,50,'cuda')$/;"	v
s	./test_super_fwd.py	/^s = utils.SuperAE(5,50,'cuda')$/;"	v
safemean	./utils.py	/^def safemean(t): return 0 if t.numel() == 0 else t.mean()$/;"	f
save_and_check	./utils.py	/^def save_and_check(enc,dec,fname):$/;"	f
scatter_clusters	./utils.py	/^def scatter_clusters(embeddings,labels,show):$/;"	f
set_experiment_dir	./utils.py	/^def set_experiment_dir(exp_name, overwrite):$/;"	f
sevens	./ae_experiments.py	/^    sevens = mnist_train.x[(mnist_train.y == 7)].to('cuda')$/;"	v
show_xb	./utils.py	/^def show_xb(xb): plt.imshow(xb[0,0]); plt.show()$/;"	f
simple_clearner	./ae_experiments.py	/^    simple_clearner = ConceptLearner(enc,dec,lin,mnist,opt=torch.optim.Adam,loss_func=nn.L1Loss(/;"	v
simple_ds	./ae_experiments.py	/^    simple_ds = utils.TransformDataset(torch.cat([ones,twos,fives,eights],dim=0), [utils.to_floa/;"	v
sixes	./ae_experiments.py	/^    sixes = mnist_train.x[(mnist_train.y == 6)].to('cuda')$/;"	v
sns	./ae_experiments.py	/^import seaborn as sns$/;"	I
sns	./min_ex.py	/^import seaborn as sns$/;"	I
sns	./multi_ae.py	/^import seaborn as sns$/;"	I
sns	./train_stacked.py	/^import seaborn as sns$/;"	I
sns	./umap_reproduce.py	/^import seaborn as sns$/;"	I
sns	./utils.py	/^import seaborn as sns$/;"	I
standard_embedding	./umap_reproduce.py	/^standard_embedding = umap.UMAP(random_state=42).fit_transform(mnist_data)$/;"	v
start_time	./test_super.py	/^start_time = time()$/;"	v
start_time	./test_super_fwd.py	/^start_time = time()$/;"	v
stats	./utils.py	/^def stats(x): return x.mean(),x.std()$/;"	f
tdatasets	./ae_experiments.py	/^import torchvision.datasets as tdatasets$/;"	I
tdatasets	./min_ex.py	/^import torchvision.datasets as tdatasets$/;"	I
tdatasets	./multi_ae.py	/^import torchvision.datasets as tdatasets$/;"	I
tdatasets	./train_stacked.py	/^import torchvision.datasets as tdatasets$/;"	I
tdatasets	./utils.py	/^import torchvision.datasets as tdatasets$/;"	I
test	./multi_ae.py	/^    def test(self,x): print(x)$/;"	m	class:AETrainer
test_mods_eq	./utils.py	/^def test_mods_eq(m1,m2):$/;"	f
threes	./ae_experiments.py	/^    threes = mnist_train.x[(mnist_train.y == 3)].to('cuda')$/;"	v
to_float_tensor	./utils.py	/^def to_float_tensor(item): return item.float().div_(255.)$/;"	f
total_loss	./test_super.py	/^        total_loss = total_loss*(i+1)\/(i+2) + loss.item()\/(i+2)$/;"	v
total_loss	./test_super.py	/^    total_loss = 0.$/;"	v
total_loss	./test_super_fwd.py	/^        total_loss = total_loss*(i+1)\/(i+2) + loss.item()\/(i+2)$/;"	v
total_loss	./test_super_fwd.py	/^    total_loss = 0.$/;"	v
total_mid_loss	./train_stacked.py	/^        total_mid_loss = total_mid_loss*(i+1)\/(i+2) + mid_loss.item()\/(i+2)$/;"	v
total_mid_loss	./train_stacked.py	/^    total_mid_loss = 0.$/;"	v
total_pred_loss	./train_stacked.py	/^        total_pred_loss = total_pred_loss*(i+1)\/(i+2) + pred_loss.item()\/(i+2)$/;"	v
total_pred_loss	./train_stacked.py	/^    total_pred_loss = 0.$/;"	v
train_ae	./ae_experiments.py	/^    def train_ae(self,ARGS):$/;"	m	class:ConceptLearner
train_ae	./min_ex.py	/^    def train_ae(self,ARGS):$/;"	m	class:ConceptLearner
train_ae	./min_ex.py	/^def train_ae(x): x.train_ae(ARGS)$/;"	f
train_ae	./multi_ae.py	/^    def train_ae(self,AE,mid_centroids_by_id,latent_centroids_by_id,ensemble_gt,all_agree):$/;"	m	class:AETrainer
train_labels	./ae_experiments.py	/^    def train_labels(self,epochs,bs):$/;"	m	class:ConceptLearner
train_labels	./min_ex.py	/^    def train_labels(self,epochs,bs):$/;"	m	class:ConceptLearner
translate_labellings	./utils.py	/^def translate_labellings(trans_from_labels,trans_to_labels):$/;"	f
twos	./ae_experiments.py	/^    twos = mnist_train.x[(mnist_train.y == 2)].to('cuda')$/;"	v
umap	./ae_experiments.py	/^import umap.umap_ as umap$/;"	I
umap	./min_ex.py	/^import umap.umap_ as umap$/;"	I
umap	./multi_ae.py	/^import umap.umap_ as umap$/;"	I
umap	./train_stacked.py	/^import umap.umap_ as umap$/;"	I
umap	./utils.py	/^import umap.umap_ as umap$/;"	I
umap_embed	./utils.py	/^def umap_embed(vectors,**config): return umap.UMAP(random_state=42).fit_transform(vectors,**conf/;"	f
vis_latent	./utils.py	/^def vis_latent(dec,latent): plt.imshow(dec(latent[None,:,None,None].cuda())[0,0]); plt.show()$/;"	f
x	./test_super.py	/^x = d[0][0][None]$/;"	v
x	./test_super_fwd.py	/^x = d[0][0][None]$/;"	v
